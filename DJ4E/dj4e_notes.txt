                                        === DJ4E Notes ===

==> URL
-> Uniform Resource Locator
-> Concept of URL is not a Socket Concept, it is a HTTP Concept

==> TCP Connections / Sockets
-> In computer networking, an internet socket or network socket is an endpoint 
    of a bidirectional inter-process communication flow across an Internet Protocol-based computer network, such as the Internet.

==> TCP Port Numbers (Transmission Control Protocol)
-> A port is an application-specific or process-specific software communications endpoint.
-> It allows multiple networked applications to coexist on the same server.
-> There is a list of well-known TCP port Numbers
---> webserver 80
---> webserver secured 443
---> login 23
---> incoming email 25

==> Virtual Environment
-> python -m venv /path/to/new/virtual/environment/env
-> 'env' here is the folder name

==> Django Shell
-> python manage.py shell
-> same as python shell but with django add-ons

==> ORM (Object Relational Mapper)
--> It maps a relation between the database and a model.
--> ORM is the layer that connects Object Oriented Programming(OOP) to Relational Databases.

-> behind the scene working of ORM:
-> from django.db import connection
-> print(connection.queries)


==> CRUD in ORM:

-> CREATE
--> u = User(name='asu', email='asu@yay.com')
--> u.save()

-> READ
--> User.objects.values()
--> User.objects.filter(email='asu@yay.com').values()

-> UPDATE
--> User.objects.filter(emai='asu@yay.com').update(name='asutosh')
--> User.object.values()

-> DELETE
--> User.objects.filter(name='asutosh').delete()
--> User.objects.values()

-> ORDER BY
--> User.objects.values().order_by('name')
--> User.objects.values().order_by('-id')   // - for descending

-> GET
--> u = User.objects.get(pk=1)
--> print(u.name)  // asutosh


==> makemigrations
-> The makemigrations command reads all the models.py files in all the applications,
    and creates / evolves the migration files
-> Guided by the applications listed in settings.py
-> migrations are portable across databases, what it means is it's just the logical,
    representation of what the tables should look like, so migrations are same for different databases

==> migrate
-> The migrate command reads all the migrations folders in the application folders,
    and creates / evolves the tables in the database
-> migrate command applies all the migrations in sequence order not just the latest one,
-> if previous ones are not applied, it remembers which migrations are applied already,
    using the django_migrations table
---> Use python manage.py check before running the migrations commands.

==> QuerySet
-> Queryset is a list of objects present in a model. 
-> We can use Querysets to filter, arrange and manage our data.
-> The main purpose of these is to make query retrieval faster and easier.


==> One-To-Many (Foreign Key):
-> class Lang(models.Model):
    name = models.CharField(max_length=128)
// foreign key id name lang_id will be autogenerated by django with autoincrement
-> class Book(models.Model):
    title = models.CharField(max_length=128)
    lang = models.ForeignKey('Lang', on_delete= models.SET_NULL, null= True)
// on_delete = models.SET_NULL -> Keep the row & set foreign key to null, requires null = True
-> class Instance(models.Model):
    book = models.ForeignKey('Book', on_delete= models.CASCADE)
    due = models.DateField(null= True, blank= True)
// on_delete = models.CASCADE -> Delete the row



==> __init__.py
-> We place an empty __init__.py file in folders to indicate to Python that,
-> these folders contains modules that are suitable for importing.


==> Loading One-To-Many Data or CSV using a Django Batch Script
-> pip install django-extensions
-> In settings.py add django_extensions in INSTALLED_APPS
-> python manage.py runscript script_name


==> Model-View-Controller (MVC)
--> Model: The persistent data that we keep in the data store -> models.py
--> View: The HTML, CSS, etc. which makes up the look and feel of the application -> views.py & templates
--> Controller: The code that does the thinking and decision making -> views.py, URL Dispatcher, etc.
--> Controller Orchestrates, is the conductor of all the other aspects of MVC


==> Tasks Inside the Server
-> process any user input data (i.e. from a form) - possibly storing it in a database or
    making some other change to the database such as a delete
-> Decide which screen to send back to the user
-> Retrieve any needed data
-> Produce the HTML response and send it back to the browser(i.e. a template)


==> Views
-> Django looks at the incoming request URL and uses urls.py to select a view
-> Views handle any incoming data in the request and copy it to the database through the model
-> Retrieve the data to put on the page form the database through the model
-> Produce the HTML that will become the response and return it to the browser
-> When Django receives an HTTP request it parses it, uses some of the URL for routing purposes and 
    passes parts of the URL to your code

--> https://sample_proj/views/danger?guess=69
--> domain name/ django application/ view within application/ URL Path Parameter or key/value Parameter

# to access the guess
--> def danger(request):
        response = """<html><body>
        <p> Your guess was """+ request.GET['guess'] +""" </p>
        </body></html> """
        return HttpResponse(response)

# Why is that view named danger?
--> It is dangerous to take data form the user and include it in the HTTP response without "escaping" the output.
--> HTML + JS is a programming language and you don't want users "sending code" to other user's browsers
--> Cross-Site Scripting (XSS)

--> from django.utils.html import escape
    """ + escape(request.GET['guess']) + """

--> user cannot provide you data that turns into code


==> URL Dispatcher
-> To design URLs for an app, you create a Python module called a URLconf (URL configuration)
-> URLconf is a mapping b/w URL path expressions to Python functions (views)

==> URL routing
->  from django.urls import path
    from . import views
    from django.views.generic import TemplateView

    app_name = 'views'

    urlpatterns = [
        # pre-defined class from Django
        path('', TemplateView.as_view(template_name='views/main.html')),
        # function based views
        path('rest/<int:guess>', views.rest),
        # class based views
        path('remain/<slug:guess>', views.RestMainView.as_view()),
    ]

--> as_view()
    : is a static method that returns a function that then can respond to the incoming request.


==> Request and Response objects
-> Django uses request and response objects to pass information throughout the django application
-> When a page is requested by the browser, Django creates an HttpRequest object 
    that contains metadata about the request
-> Then Django loads the appropriate view, passing the HttpRequest as the first argument to the view function
-> Each view is responsible for returning an HttpResponse object
-> The Application Programming Interfaces (APIs) for HttpRequest and HttpResponse objects,
    are defined in the django.http module.

==> class HttpRequest
-> Attributes
--> All attributes should be considered read-only, unless stated otherwise
-> HttpRequest.scheme
--> A string representing the scheme of the request (http or https usually)
-> HttpRequest.body
--> The raw HTTP request body as a bytestring. This is useful for processing data in different ways
    than conventional HTML forms: binary imgs, XML payload etc. For processing conventional form data,
    use HttpRequest.POST
-> HttpRequest object is an object instance of class HTTP request


==> class HttpResponse
-> In contrast to HttpRequest objects, which are created automatically by Django, HttpResponse objects
    are our responsiblity
-> Each view we write is responsible for instantiating, populating, and returning an HttpResponse
--> Passing Strings
    : typical usage is to pass the contents of the page, as a string or bytestring, to the HttpResponse constructor.




